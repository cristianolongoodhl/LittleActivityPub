<!DOCTYPE html>
<html lang="en">
<head>
	<title>Little Activity Pub Server</title>
	<meta charset="UTF-8" />
	<link rel="stylesheet" type="text/css"
		href="https://www.w3schools.com/w3css/4/w3.css" />
	<link id="style" rel="stylesheet" type="text/css" href="lap.css" />
</head>
<body>
	<h1>Just a Little Activity Pub Server - Send an Activity</h1>
	<div class="w3-card-4">
		<form action="send.php" method="post" class="w3-container" id="form">
			<p>
				<label>Inbox <input type="url" name="inbox"
					class="w3-input w3-border" /></label>
			</p>
			<p>
				<label>Activity <textarea name="activity" id="activity" class="w3-input w3-border"
						rows="20"></textarea></label>
			</p>
			<p>
				<label>Your private key <textarea
						placeholder="Put your private key pem here" name="privateKey"
						class="w3-input w3-border" rows="10" id="privateKey"></textarea>
				</label>
			</p>
 			<p>
				<input type="submit" name="sendActivity" value="Send"
					class="w3-btn w3-teal" />
			</p>
		</form>
	</div>
	<div class="w3-card-4" id="request" hidden="true" tabindex="5">
		<div class="w3-container w3-teal">
			<h2>Request details</h2>
		</div>
		<div class="w3-container">
			<p>This section describe the HTTP request which will be sent to the target inboxes and some of the processing performed to generate id.</p>
			<h3>Activity digest</h3>
			<pre class="w3-card-4"><code id="digest">processing, please wait</code></pre>
			<h3>Signature header string to be signed</h3>
			<pre class="w3-card-4"><code id="tobesigned">processing, please wait</code></pre>
			<h3>Signature header string signature</h3>
			<p class="w3-card-4" style="word-wrap:break-word;"><code id="signature">processing, please wait</code></p>
		</div>
	</div>
	<script>
const form=document.getElementById("form");
const te=new TextEncoder("UTF-8"); 

form.addEventListener('submit', (e) => {
	unhideRequestSection();
	e.preventDefault();
	const date=getDate();
	const activity=removeLineBreaksFromActivity();  
	try{
		Promise.all([createActivityDigestPromise(activity).then(printActivityDigest),
			importPrivateKey(form.privateKey.value.trim()),
			retrieveSenderActorKeyId(activity)])
		.then((values) => {
			const digest=values[0];
			const privateKey=values[1];
			const toBeSigned = "date: "+date+"\ndigest: "+digest;
			document.getElementById("tobesigned").innerHTML=toBeSigned;		
			return createSignPromise(privateKey, toBeSigned);
		}).then(printSignature).catch((error)=>{ window.alert(error); });
	} catch(error){
		window.alert(error);
	}
	//.then(()=>{form.submit();});
});	

function unhideRequestSection(){
	const requestSectionEl = document.getElementById("request");
	requestSectionEl.removeAttribute("hidden");
	requestSectionEl.focus();
}
/**
 * Get the current date, in the format required by HTTPS message signature
 */
function getDate(){
  const currentTime=new Date();
  return currentTime.toUTCString();
}

/**
 * Remove line breaks.
 *
 * we remove line breaks as LF may be changed to CRLF on submit
 * see https://stackoverflow.com/questions/69835705/formdata-textarea-puts-r-carriage-return-when-sent-with-post
 */ 
function removeLineBreaksFromActivity(){
  const message=form.activity.value.replace(/\r/g, '').replace(/\n/g, '');  
  form.activity.value=message;
  return message;
}


/**
 * Retrieve the actor at the specified URI and return its private key id.
 * @return a promise which will result in the sender actor key id
 */
function retrieveSenderActorKeyId(activity){
	const senderActorURI=getSenderActorURI(activity);
	return fetch(senderActorURI, { 
		headers: {
      			"Accept": "application/activity+json"
    		}
    	}).then((response) => {
			if (!response.ok){
				const errMsg = "Unable to retrieve actor "+senderActorURI+": "+response.status+" "+response.statusText;
				window.alert(errMsg);
				throw new Error(errMsg);
			}
		}, (error) => {
			form.activity.focus();
			throw new Error("Unable to retrieve actor "+senderActorURI+": "+error);
		}
	);
}

/**
 * Retrieve actor URI from the activity field. If retrieving fails, show an error message
 * 
 * @return the actor indicated in the activity
 * @throw error if activity is not a valid json of if it has no actor property specified in it 
 */
function getSenderActorURI(activity){
	try{
		const activityAsJSON = JSON.parse(activity);
		if (activityAsJSON.actor!==undefined) return activityAsJSON.actor;
		form.activity.focus();
		throw new Error("No actor specified in activity");
	}catch (e) {
		form.activity.focus();
		throw new Error("Activity field content is not a valid JSON: "+e);
	}
}

/**
 * Create a digest of the activity field and use it to set the value of the digest field
 *
 * @return a promise
 */
function createActivityDigestPromise(activity){
  const buff=te.encode(activity);
  return window.crypto.subtle.digest('SHA-256', buff).then(param => {
  	// https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string
    return "SHA-256="+btoa(String.fromCharCode(...new Uint8Array(param)));
  });
}

/**
 * Provide the activity digest in the Request details section
 */
function printActivityDigest(digest){
	document.getElementById("digest").innerHTML=digest;
	return digest;
}

//see https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#pkcs_8_import
function str2ab(str) {
  const buf = new ArrayBuffer(str.length);
  const bufView = new Uint8Array(buf);
  for (let i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}

/*
Import a PEM encoded RSA private key, to use for RSA-PSS signing.
Takes a string containing the PEM encoded key, and returns a Promise
that will resolve to a CryptoKey representing the private key.
*/
function importPrivateKey(pem) {
  // fetch the part of the PEM string between header and footer
  const pemHeader = "-----BEGIN PRIVATE KEY-----";
  const pemFooter = "-----END PRIVATE KEY-----";
  const pemContents = pem.substring(
    pemHeader.length,
    pem.length - pemFooter.length
  );
  // base64 decode the string to get the binary data
  const binaryDerString = window.atob(pemContents);
  // convert from a binary string to an ArrayBuffer
  const binaryDer = str2ab(binaryDerString);

  return window.crypto.subtle.importKey(
    "pkcs8",
    binaryDer,
	   {
	     name: "RSASSA-PKCS1-v1_5",
	     hash: "SHA-256"
	   },
	false, //true,
    ["sign"]
  );
}

/**
 * Get a promise which will generate the signature for the signature header from date and digest field values
 * and set the signature field value
 */
function createSignPromise(privateKey, date, digest){
	const toBeSigned = "date: "+date+"\ndigest: "+digest;
	return window.crypto.subtle.sign(
		"RSASSA-PKCS1-v1_5",
	  	privateKey,
	  	te.encode(toBeSigned));
}

/**
 * Get a promise which will generate the signature for the signature header from date and digest field values
 * and set the signature field value
 */
function createSignPromise(privateKey, toBeSigned){
	return window.crypto.subtle.sign(
		"RSASSA-PKCS1-v1_5",
	  	privateKey,
	  	te.encode(toBeSigned));
	  	
//	  	.then((signature) => {
//	  		form.signature.value=btoa(String.fromCharCode(...new Uint8Array(signature)));
//	  	}) ; 	
}

/**
 * Provide the signature in the Request details section
 */
function printSignature(signature){
	document.getElementById("signature").innerHTML=btoa(String.fromCharCode(...new Uint8Array(signature)));
	return signature;
}

	</script>
</body>
</html>
